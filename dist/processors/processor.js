"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const utils_1 = require("~/utils");
const processor_models_1 = require("~/models/processor-models");
/**
 * Caches file mtime
 */
const MTIME_CACHE = new Map();
class Processor {
    constructor() {
        if (new.target === Processor) {
            utils_1.Utils.fatal('This class can not be instantiated.');
        }
        this.name = this.constructor.name;
        utils_1.Utils.dbg() && utils_1.Utils.debug(`${this.name} created.`);
    }
    get id() {
        return this.name;
    }
    process(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_1.Utils.dbg()) {
                utils_1.Utils.debug(`Calling ${this.name}.process().`);
                utils_1.Utils.debug('Input:', input);
            }
            let output = new processor_models_1.ProcessorOutput(input.sourceDir, input.workDir);
            return Promise.all([...input.values()].map((entry) => __awaiter(this, void 0, void 0, function* () {
                let { source, target, shouldCompile, lastOutput } = entry;
                let sourceMtime = (yield fs.stat(source)).mtimeMs;
                let sourceChanged = MTIME_CACHE.get(source) !== sourceMtime;
                let result;
                if (utils_1.Utils.dbg()) {
                    utils_1.Utils.debug(`${this.name} ${source} changed? ${sourceChanged}`);
                    utils_1.Utils.debug(`${this.name} forced compile?  ${shouldCompile}`);
                }
                if (sourceChanged || shouldCompile) {
                    let raw;
                    try {
                        raw = (yield this.processFile(source, target)) || new processor_models_1.ProcessResult();
                    }
                    catch (ex) {
                        utils_1.Utils.error(`Error in ${this.name}:`, ex);
                        output.failures.push(source);
                        return;
                    }
                    result = new processor_models_1.ProcessorOutputEntry(source, raw.target || target, 
                    // Incremental build relies on two assumptions here:
                    // 1. Imported files returned by processors are flattened, meaning
                    //    if A contains B, and B contains C, both B and C present in
                    //    raw.imports.
                    // 2. Processors handle circular imports properly, either throw
                    //    errors or somehow solve them.
                    utils_1.Utils.union([source], raw.imports));
                    MTIME_CACHE.set(source, sourceMtime);
                    utils_1.Utils.info(`${this.name}: Processed ${source}`);
                }
                else {
                    // Only include properties which should be generated by Processor
                    // to avoid side effects.
                    result = new processor_models_1.ProcessorOutputEntry(lastOutput.source, lastOutput.target, lastOutput.contains);
                }
                if (utils_1.Utils.dbg()) {
                    utils_1.Utils.debug(`${this.name}: ${result.source} -> ${result.target}.`);
                    utils_1.Utils.debug(`${this.name}: ${result.target} imported`, result.contains);
                }
                output.add(result);
            }))).then(() => output);
        });
    }
}
exports.Processor = Processor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Byb2Nlc3NvcnMvcHJvY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQWdDO0FBQ2hDLGdFQUltQztBQUVuQzs7R0FFRztBQUNILE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0FBRTlDO0lBR0U7UUFDRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsYUFBSyxDQUFDLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1FBQ2xDLGFBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxhQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUlELElBQUksRUFBRTtRQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFSyxPQUFPLENBQUMsS0FBcUI7O1lBQ2pDLEVBQUUsQ0FBQyxDQUFDLGFBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLGFBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQztnQkFDL0MsYUFBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDL0IsQ0FBQztZQUNELElBQUksTUFBTSxHQUFvQixJQUFJLGtDQUFlLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FB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Q0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QixDQUFDO0tBQUE7Q0FDRjtBQXpFRCw4QkF5RUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJ34vdXRpbHMnO1xuaW1wb3J0IHtcbiAgUHJvY2Vzc29ySW5wdXQsIFByb2Nlc3NvcklucHV0RW50cnksXG4gIFByb2Nlc3Nvck91dHB1dCwgUHJvY2Vzc29yT3V0cHV0RW50cnksXG4gIFByb2Nlc3NSZXN1bHRcbn0gZnJvbSAnfi9tb2RlbHMvcHJvY2Vzc29yLW1vZGVscyc7XG5cbi8qKlxuICogQ2FjaGVzIGZpbGUgbXRpbWVcbiAqL1xuY29uc3QgTVRJTUVfQ0FDSEUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUHJvY2Vzc29yIHtcbiAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAobmV3LnRhcmdldCA9PT0gUHJvY2Vzc29yKSB7XG4gICAgICBVdGlscy5mYXRhbCgnVGhpcyBjbGFzcyBjYW4gbm90IGJlIGluc3RhbnRpYXRlZC4nKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIFV0aWxzLmRiZygpICYmIFV0aWxzLmRlYnVnKGAke3RoaXMubmFtZX0gY3JlYXRlZC5gKTtcbiAgfVxuXG4gIGFic3RyYWN0IGFzeW5jIHByb2Nlc3NGaWxlKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD47XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3MoaW5wdXQ6IFByb2Nlc3NvcklucHV0KTogUHJvbWlzZTxQcm9jZXNzb3JPdXRwdXQ+IHtcbiAgICBpZiAoVXRpbHMuZGJnKCkpIHtcbiAgICAgIFV0aWxzLmRlYnVnKGBDYWxsaW5nICR7dGhpcy5uYW1lfS5wcm9jZXNzKCkuYCk7XG4gICAgICBVdGlscy5kZWJ1ZygnSW5wdXQ6JywgaW5wdXQpO1xuICAgIH1cbiAgICBsZXQgb3V0cHV0OiBQcm9jZXNzb3JPdXRwdXQgPSBuZXcgUHJvY2Vzc29yT3V0cHV0KGlucHV0LnNvdXJjZURpciwgaW5wdXQud29ya0Rpcik7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5pbnB1dC52YWx1ZXMoKV0ubWFwKGFzeW5jIGVudHJ5ID0+IHtcbiAgICAgIGxldCB7IHNvdXJjZSwgdGFyZ2V0LCBzaG91bGRDb21waWxlLCBsYXN0T3V0cHV0IH0gPSBlbnRyeTtcbiAgICAgIGxldCBzb3VyY2VNdGltZTogbnVtYmVyID0gKGF3YWl0IGZzLnN0YXQoc291cmNlKSkubXRpbWVNcztcbiAgICAgIGxldCBzb3VyY2VDaGFuZ2VkOiBib29sZWFuID0gTVRJTUVfQ0FDSEUuZ2V0KHNvdXJjZSkgIT09IHNvdXJjZU10aW1lO1xuICAgICAgbGV0IHJlc3VsdDogUHJvY2Vzc29yT3V0cHV0RW50cnk7XG5cbiAgICAgIGlmIChVdGlscy5kYmcoKSkge1xuICAgICAgICBVdGlscy5kZWJ1ZyhgJHt0aGlzLm5hbWV9ICR7c291cmNlfSBjaGFuZ2VkPyAke3NvdXJjZUNoYW5nZWR9YCk7XG4gICAgICAgIFV0aWxzLmRlYnVnKGAke3RoaXMubmFtZX0gZm9yY2VkIGNvbXBpbGU/ICAke3Nob3VsZENvbXBpbGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VDaGFuZ2VkIHx8IHNob3VsZENvbXBpbGUpIHtcbiAgICAgICAgbGV0IHJhdzogUHJvY2Vzc1Jlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYXcgPSBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKHNvdXJjZSwgdGFyZ2V0KSB8fCBuZXcgUHJvY2Vzc1Jlc3VsdCgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIFV0aWxzLmVycm9yKGBFcnJvciBpbiAke3RoaXMubmFtZX06YCwgZXgpO1xuICAgICAgICAgIG91dHB1dC5mYWlsdXJlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBQcm9jZXNzb3JPdXRwdXRFbnRyeShcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHJhdy50YXJnZXQgfHwgdGFyZ2V0LFxuICAgICAgICAgICAgLy8gSW5jcmVtZW50YWwgYnVpbGQgcmVsaWVzIG9uIHR3byBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgICAgICAgLy8gMS4gSW1wb3J0ZWQgZmlsZXMgcmV0dXJuZWQgYnkgcHJvY2Vzc29ycyBhcmUgZmxhdHRlbmVkLCBtZWFuaW5nXG4gICAgICAgICAgICAvLyAgICBpZiBBIGNvbnRhaW5zIEIsIGFuZCBCIGNvbnRhaW5zIEMsIGJvdGggQiBhbmQgQyBwcmVzZW50IGluXG4gICAgICAgICAgICAvLyAgICByYXcuaW1wb3J0cy5cbiAgICAgICAgICAgIC8vIDIuIFByb2Nlc3NvcnMgaGFuZGxlIGNpcmN1bGFyIGltcG9ydHMgcHJvcGVybHksIGVpdGhlciB0aHJvd1xuICAgICAgICAgICAgLy8gICAgZXJyb3JzIG9yIHNvbWVob3cgc29sdmUgdGhlbS5cbiAgICAgICAgICAgIFV0aWxzLnVuaW9uKFsgc291cmNlIF0sIHJhdy5pbXBvcnRzKVxuICAgICAgICApO1xuICAgICAgICBNVElNRV9DQUNIRS5zZXQoc291cmNlLCBzb3VyY2VNdGltZSk7XG4gICAgICAgIFV0aWxzLmluZm8oYCR7dGhpcy5uYW1lfTogUHJvY2Vzc2VkICR7c291cmNlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIHByb3BlcnRpZXMgd2hpY2ggc2hvdWxkIGJlIGdlbmVyYXRlZCBieSBQcm9jZXNzb3JcbiAgICAgICAgLy8gdG8gYXZvaWQgc2lkZSBlZmZlY3RzLlxuICAgICAgICByZXN1bHQgPSBuZXcgUHJvY2Vzc29yT3V0cHV0RW50cnkoXG4gICAgICAgICAgICBsYXN0T3V0cHV0LnNvdXJjZSxcbiAgICAgICAgICAgIGxhc3RPdXRwdXQudGFyZ2V0LFxuICAgICAgICAgICAgbGFzdE91dHB1dC5jb250YWluc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbHMuZGJnKCkpIHtcbiAgICAgICAgVXRpbHMuZGVidWcoYCR7dGhpcy5uYW1lfTogJHtyZXN1bHQuc291cmNlfSAtPiAke3Jlc3VsdC50YXJnZXR9LmApO1xuICAgICAgICBVdGlscy5kZWJ1ZyhgJHt0aGlzLm5hbWV9OiAke3Jlc3VsdC50YXJnZXR9IGltcG9ydGVkYCwgcmVzdWx0LmNvbnRhaW5zKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dC5hZGQocmVzdWx0KTtcbiAgICB9KSkudGhlbigoKSA9PiBvdXRwdXQpO1xuICB9XG59Il19