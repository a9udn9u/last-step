"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const utils_1 = require("~/utils");
const processor_models_1 = require("~/models/processor-models");
/**
 * Caches file mtime
 */
const MTIME_CACHE = new Map();
class Processor {
    constructor() {
        if (new.target === Processor) {
            utils_1.Utils.fatal('This class can not be instantiated.');
        }
        this.name = this.constructor.name;
        utils_1.Utils.dbg() && utils_1.Utils.debug(`${this.name} created.`);
    }
    get id() {
        return this.name;
    }
    process(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_1.Utils.dbg()) {
                utils_1.Utils.debug(`Calling ${this.name}.process().`);
                utils_1.Utils.debug('Input:', input);
            }
            let output = new processor_models_1.ProcessorOutput();
            return Promise.all([...input.values()].map((entry) => __awaiter(this, void 0, void 0, function* () {
                let { source, target, shouldCompile, lastOutput } = entry;
                let sourceMtime = (yield fs.stat(source)).mtimeMs;
                let sourceChanged = MTIME_CACHE.get(source) !== sourceMtime;
                let result;
                if (utils_1.Utils.dbg()) {
                    utils_1.Utils.debug(`${this.name} ${source} changed? ${sourceChanged}`);
                    utils_1.Utils.debug(`${this.name} forced compile?  ${shouldCompile}`);
                }
                if (sourceChanged || shouldCompile) {
                    let raw;
                    try {
                        raw = (yield this.processFile(source, target)) || new processor_models_1.ProcessResult();
                    }
                    catch (ex) {
                        utils_1.Utils.error(`Error in ${this.name}:`, ex);
                        output.failures.push(source);
                        return;
                    }
                    result = new processor_models_1.ProcessorOutputEntry(source, raw.target || target, 
                    // Incremental build relies on two assumptions here:
                    // 1. Imported files returned by processors are flattened, meaning
                    //    if A contains B, and B contains C, both B and C present in
                    //    raw.imports.
                    // 2. Processors handle circular imports properly, either throw
                    //    errors or somehow solve them.
                    utils_1.Utils.union([source], raw.imports));
                    MTIME_CACHE.set(source, sourceMtime);
                }
                else {
                    // Only include properties which should be generated by Processor
                    // to avoid side effects.
                    result = new processor_models_1.ProcessorOutputEntry(lastOutput.source, lastOutput.target, lastOutput.contains);
                }
                if (utils_1.Utils.dbg()) {
                    utils_1.Utils.debug(`${this.name}: ${result.source} -> ${result.target}.`);
                    utils_1.Utils.debug(`${this.name}: ${result.target} imported`, result.contains);
                }
                output.add(result);
            }))).then(() => output);
        });
    }
}
exports.Processor = Processor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Byb2Nlc3NvcnMvcHJvY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQWdDO0FBQ2hDLGdFQUltQztBQUVuQzs7R0FFRztBQUNILE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0FBRTlDO0lBR0U7UUFDRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsYUFBSyxDQUFDLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1FBQ2xDLGFBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxhQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUlELElBQUksRUFBRTtRQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFSyxPQUFPLENBQUMsS0FBcUI7O1lBQ2pDLEVBQUUsQ0FBQyxDQUFDLGFBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLGFBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQztnQkFDL0MsYUFBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDL0IsQ0FBQztZQUNELElBQUksTUFBTSxHQUFvQixJQUFJLGtDQUFlLEVBQUUsQ0FBQztZQUNwRCxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQU0sS0FB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dCB7IFV0aWxzIH0gZnJvbSAnfi91dGlscyc7XG5pbXBvcnQge1xuICBQcm9jZXNzb3JJbnB1dCwgUHJvY2Vzc29ySW5wdXRFbnRyeSxcbiAgUHJvY2Vzc29yT3V0cHV0LCBQcm9jZXNzb3JPdXRwdXRFbnRyeSxcbiAgUHJvY2Vzc1Jlc3VsdFxufSBmcm9tICd+L21vZGVscy9wcm9jZXNzb3ItbW9kZWxzJztcblxuLyoqXG4gKiBDYWNoZXMgZmlsZSBtdGltZVxuICovXG5jb25zdCBNVElNRV9DQUNIRSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9jZXNzb3Ige1xuICBwcm90ZWN0ZWQgbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmIChuZXcudGFyZ2V0ID09PSBQcm9jZXNzb3IpIHtcbiAgICAgIFV0aWxzLmZhdGFsKCdUaGlzIGNsYXNzIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLicpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgVXRpbHMuZGJnKCkgJiYgVXRpbHMuZGVidWcoYCR7dGhpcy5uYW1lfSBjcmVhdGVkLmApO1xuICB9XG5cbiAgYWJzdHJhY3QgYXN5bmMgcHJvY2Vzc0ZpbGUoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKTogUHJvbWlzZTxQcm9jZXNzUmVzdWx0PjtcblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgYXN5bmMgcHJvY2VzcyhpbnB1dDogUHJvY2Vzc29ySW5wdXQpOiBQcm9taXNlPFByb2Nlc3Nvck91dHB1dD4ge1xuICAgIGlmIChVdGlscy5kYmcoKSkge1xuICAgICAgVXRpbHMuZGVidWcoYENhbGxpbmcgJHt0aGlzLm5hbWV9LnByb2Nlc3MoKS5gKTtcbiAgICAgIFV0aWxzLmRlYnVnKCdJbnB1dDonLCBpbnB1dCk7XG4gICAgfVxuICAgIGxldCBvdXRwdXQ6IFByb2Nlc3Nvck91dHB1dCA9IG5ldyBQcm9jZXNzb3JPdXRwdXQoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLmlucHV0LnZhbHVlcygpXS5tYXAoYXN5bmMgZW50cnkgPT4ge1xuICAgICAgbGV0IHsgc291cmNlLCB0YXJnZXQsIHNob3VsZENvbXBpbGUsIGxhc3RPdXRwdXQgfSA9IGVudHJ5O1xuICAgICAgbGV0IHNvdXJjZU10aW1lOiBudW1iZXIgPSAoYXdhaXQgZnMuc3RhdChzb3VyY2UpKS5tdGltZU1zO1xuICAgICAgbGV0IHNvdXJjZUNoYW5nZWQ6IGJvb2xlYW4gPSBNVElNRV9DQUNIRS5nZXQoc291cmNlKSAhPT0gc291cmNlTXRpbWU7XG4gICAgICBsZXQgcmVzdWx0OiBQcm9jZXNzb3JPdXRwdXRFbnRyeTtcblxuICAgICAgaWYgKFV0aWxzLmRiZygpKSB7XG4gICAgICAgIFV0aWxzLmRlYnVnKGAke3RoaXMubmFtZX0gJHtzb3VyY2V9IGNoYW5nZWQ/ICR7c291cmNlQ2hhbmdlZH1gKTtcbiAgICAgICAgVXRpbHMuZGVidWcoYCR7dGhpcy5uYW1lfSBmb3JjZWQgY29tcGlsZT8gICR7c2hvdWxkQ29tcGlsZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUNoYW5nZWQgfHwgc2hvdWxkQ29tcGlsZSkge1xuICAgICAgICBsZXQgcmF3OiBQcm9jZXNzUmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJhdyA9IGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGUoc291cmNlLCB0YXJnZXQpIHx8IG5ldyBQcm9jZXNzUmVzdWx0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgVXRpbHMuZXJyb3IoYEVycm9yIGluICR7dGhpcy5uYW1lfTpgLCBleCk7XG4gICAgICAgICAgb3V0cHV0LmZhaWx1cmVzLnB1c2goc291cmNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IFByb2Nlc3Nvck91dHB1dEVudHJ5KFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgcmF3LnRhcmdldCB8fCB0YXJnZXQsXG4gICAgICAgICAgICAvLyBJbmNyZW1lbnRhbCBidWlsZCByZWxpZXMgb24gdHdvIGFzc3VtcHRpb25zIGhlcmU6XG4gICAgICAgICAgICAvLyAxLiBJbXBvcnRlZCBmaWxlcyByZXR1cm5lZCBieSBwcm9jZXNzb3JzIGFyZSBmbGF0dGVuZWQsIG1lYW5pbmdcbiAgICAgICAgICAgIC8vICAgIGlmIEEgY29udGFpbnMgQiwgYW5kIEIgY29udGFpbnMgQywgYm90aCBCIGFuZCBDIHByZXNlbnQgaW5cbiAgICAgICAgICAgIC8vICAgIHJhdy5pbXBvcnRzLlxuICAgICAgICAgICAgLy8gMi4gUHJvY2Vzc29ycyBoYW5kbGUgY2lyY3VsYXIgaW1wb3J0cyBwcm9wZXJseSwgZWl0aGVyIHRocm93XG4gICAgICAgICAgICAvLyAgICBlcnJvcnMgb3Igc29tZWhvdyBzb2x2ZSB0aGVtLlxuICAgICAgICAgICAgVXRpbHMudW5pb24oWyBzb3VyY2UgXSwgcmF3LmltcG9ydHMpXG4gICAgICAgICk7XG4gICAgICAgIE1USU1FX0NBQ0hFLnNldChzb3VyY2UsIHNvdXJjZU10aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCBiZSBnZW5lcmF0ZWQgYnkgUHJvY2Vzc29yXG4gICAgICAgIC8vIHRvIGF2b2lkIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgcmVzdWx0ID0gbmV3IFByb2Nlc3Nvck91dHB1dEVudHJ5KFxuICAgICAgICAgICAgbGFzdE91dHB1dC5zb3VyY2UsXG4gICAgICAgICAgICBsYXN0T3V0cHV0LnRhcmdldCxcbiAgICAgICAgICAgIGxhc3RPdXRwdXQuY29udGFpbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxzLmRiZygpKSB7XG4gICAgICAgIFV0aWxzLmRlYnVnKGAke3RoaXMubmFtZX06ICR7cmVzdWx0LnNvdXJjZX0gLT4gJHtyZXN1bHQudGFyZ2V0fS5gKTtcbiAgICAgICAgVXRpbHMuZGVidWcoYCR7dGhpcy5uYW1lfTogJHtyZXN1bHQudGFyZ2V0fSBpbXBvcnRlZGAsIHJlc3VsdC5jb250YWlucyk7XG4gICAgICB9XG4gICAgICBvdXRwdXQuYWRkKHJlc3VsdCk7XG4gICAgfSkpLnRoZW4oKCkgPT4gb3V0cHV0KTtcbiAgfVxufSJdfQ==