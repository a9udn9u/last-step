import * as fs from 'fs-extra';
import { Utils } from '~/utils';
import {
  ProcessorInput, ProcessorInputEntry,
  ProcessorOutput, ProcessorOutputEntry,
  ProcessResult
} from '~/models/processor-models';

/**
 * Caches file mtime
 */
const MTIME_CACHE = new Map<string, number>();

export abstract class Processor {
  protected name: string;

  constructor() {
    if (new.target === Processor) {
      Utils.fatal('This class can not be instantiated.');
    }
    this.name = this.constructor.name;
    Utils.dbg() && Utils.debug(`${this.name} created.`);
  }

  abstract async processFile(source: string, target: string): Promise<ProcessResult>;

  get id(): string {
    return this.name;
  }

  async process(input: ProcessorInput): Promise<ProcessorOutput> {
    if (Utils.dbg()) {
      Utils.debug(`Calling ${this.name}.process().`);
      Utils.debug('Input:', input);
    }
    let output: ProcessorOutput = new ProcessorOutput();
    return Promise.all([...input.values()].map(async entry => {
      let { source, target, shouldCompile, lastOutput } = entry;
      let sourceMtime: number = (await fs.stat(source)).mtimeMs;
      let sourceChanged: boolean = MTIME_CACHE.get(source) !== sourceMtime;
      let result: ProcessorOutputEntry;

      if (Utils.dbg()) {
        Utils.debug(`${this.name} ${source} changed? ${sourceChanged}`);
        Utils.debug(`${this.name} forced compile?  ${shouldCompile}`);
      }

      if (sourceChanged || shouldCompile) {
        let raw: ProcessResult;
        try {
          raw = await this.processFile(source, target) || new ProcessResult();
        } catch (ex) {
          Utils.error(`Error in ${this.name}:`, ex);
          output.failures.push(source);
          return;
        }
        result = new ProcessorOutputEntry(
            source,
            raw.target || target,
            // Incremental build relies on two assumptions here:
            // 1. Imported files returned by processors are flattened, meaning
            //    if A contains B, and B contains C, both B and C present in
            //    raw.imports.
            // 2. Processors handle circular imports properly, either throw
            //    errors or somehow solve them.
            Utils.union([ source ], raw.imports)
        );
        MTIME_CACHE.set(source, sourceMtime);
      } else {
        // Only include properties which should be generated by Processor
        // to avoid side effects.
        result = new ProcessorOutputEntry(
            lastOutput.source,
            lastOutput.target,
            lastOutput.contains
        );
      }

      if (Utils.dbg()) {
        Utils.debug(`${this.name}: ${result.source} -> ${result.target}.`);
        Utils.debug(`${this.name}: ${result.target} imported`, result.contains);
      }
      output.add(result);
    })).then(() => output);
  }
}